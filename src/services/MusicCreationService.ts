import { supabase } from "@/integrations/supabase/client";
import { OrderStatusService } from "./OrderStatusService";
import i18n from "@/lib/i18n";

/**
 * MusicCreationService
 * Servi√ßo unificado para todas as formas de cria√ß√£o de m√∫sica.
 */

export interface ApproveLyricsParams {
  orderId: string;
  lyricId: string;
  approvedLyrics: string;
  songTitle: string;
  pronunciations?: Array<{ term: string; phonetic: string }>;
  hasCustomLyric?: boolean;
  customCoverUrl?: string | null;
  coverMode?: string;
  briefing: {
    musicType: string;
    emotion: string;
    emotionIntensity: number;
    style: string;
    rhythm: string;
    atmosphere: string;
    hasMonologue?: boolean;
    voiceType?: string;
    isInstrumental?: boolean;
    hasCustomLyric?: boolean;
    songName?: string;
  };
}

export interface ApprovalResult {
  success: boolean;
  alreadyProcessed?: boolean;
  missingPronunciations?: string[];
  error?: string;
}

let approvalInFlight = false;

export class MusicCreationService {
  /* ================================
     M√âTODO PRINCIPAL
  ================================= */
  static async approveLyrics(params: ApproveLyricsParams): Promise<ApprovalResult> {
    if (approvalInFlight) {
      return { success: false, error: "A√ß√£o j√° em andamento" };
    }

    approvalInFlight = true;

    try {
      const validation = await OrderStatusService.canApproveLyrics(params.orderId);

      if (validation?.alreadyApproved) {
        return { success: true, alreadyProcessed: true };
      }

      if (!validation?.canApprove) {
        return { success: false, error: validation?.reason };
      }

      const normalizedCover = this.normalizeCoverUrl(params.customCoverUrl);
      const autoPronunciations = this.autoFixPronunciations(params.approvedLyrics, params.pronunciations || []);

      const { data, error } = await supabase.functions.invoke("generate-style-prompt", {
        body: {
          orderId: params.orderId,
          lyricId: params.lyricId,
          approvedLyrics: params.approvedLyrics,
          songTitle: params.songTitle,
          pronunciations: autoPronunciations,
          hasCustomLyric: params.hasCustomLyric || false,
          customCoverUrl: normalizedCover,
          coverMode: params.coverMode || "auto",
          language: this.getActiveLanguage(),
          briefing: params.briefing,
        },
      });

      if (error) {
        const parsed = this.parseEdgeFunctionError(error);

        // üî• N√ÉO bloquear por mai√∫sculas simples
        if (parsed?.missingPronunciations?.length) {
          const filtered = parsed.missingPronunciations.filter((word: string) => this.shouldReallyBlock(word));

          if (filtered.length > 0) {
            return { success: false, missingPronunciations: filtered };
          }
        }

        const postCheck = await OrderStatusService.isAlreadyProcessed(params.orderId);
        if (postCheck) {
          return { success: true, alreadyProcessed: true };
        }

        return { success: false, error: parsed?.error || error.message };
      }

      if (!data?.ok) {
        const postCheck = await OrderStatusService.isAlreadyProcessed(params.orderId);
        if (postCheck) {
          return { success: true, alreadyProcessed: true };
        }
        return { success: false, error: data?.error || "Erro ao gerar m√∫sica" };
      }

      return { success: true };
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);

      try {
        const postCheck = await OrderStatusService.isAlreadyProcessed(params.orderId);
        if (postCheck) {
          return { success: true, alreadyProcessed: true };
        }
      } catch {}

      return { success: false, error: msg };
    } finally {
      approvalInFlight = false;
    }
  }

  /* ================================
     NORMALIZA√á√ÉO DE CAPA
  ================================= */
  private static normalizeCoverUrl(url?: string | null): string | null {
    if (!url) return null;

    const trimmed = url.trim();

    if (!trimmed) return null;

    // N√£o permitir base64 gigantes
    if (trimmed.startsWith("data:image")) {
      if (trimmed.length > 2_000_000) {
        return null;
      }
    }

    try {
      new URL(trimmed);
      return trimmed;
    } catch {
      return null;
    }
  }

  /* ================================
     CORRE√á√ÉO AUTOM√ÅTICA DE PRON√öNCIA
  ================================= */
  private static autoFixPronunciations(text: string, existing: Array<{ term: string; phonetic: string }>) {
    const words = text.match(/\b[A-Z√Ä-√ö][a-z√†-√∫]+\b/g) || [];

    const autoGenerated = words.map((word) => ({
      term: word,
      phonetic: word.toLowerCase(),
    }));

    return [...existing, ...autoGenerated];
  }

  private static shouldReallyBlock(word: string): boolean {
    // Bloquear apenas se tiver n√∫meros ou s√≠mbolos estranhos
    return /[^a-zA-Z√Ä-√∫]/.test(word);
  }

  /* ================================
     IDIOMA ATIVO
  ================================= */
  static getActiveLanguage(): string {
    return i18n.resolvedLanguage || i18n.language || "pt-BR";
  }

  /* ================================
     PARSER DE ERRO
  ================================= */
  private static parseEdgeFunctionError(error: any): any {
    try {
      const ctx = error?.context;

      if (ctx?.body) {
        return typeof ctx.body === "string" ? JSON.parse(ctx.body) : ctx.body;
      }

      const match = error?.message?.match(/body\s*({.+})/);
      if (match) return JSON.parse(match[1]);
    } catch {}

    return null;
  }
}
